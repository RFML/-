
参考博客：https://blog.csdn.net/u013457167/article/details/81989207

一、算法概述

1.1 算法分类

比较类排序：通过比较来决定元素间的相对次序。

    时间复杂度O(nlogn) ~ O(n^2)，主要有：冒泡排序，选择排序，插入排序，归并排序，堆排序，快速排序等。
 
非比较排序：不通过比较来决定元素间的相对次序 

    时间复杂度可以达到O(n)，主要有：计数排序，基数排序，桶排序等。 

分类图如下：
![Image text](https://github.com/RFML/sortofeight/blob/master/images/排序算法分类.png)

1.2 算法复杂度及稳定性
![Image text](https://github.com/RFML/sortofeight/blob/master/images/各类排序算法复杂度.png)

二、详细讲解

2.1 冒泡排序

算法原理:(升序)

	(1)比较相邻的元素。如果第一个比第二个大，就交换他们两个。
	(2)对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。在这一步，最后的元素应该会是最大的数。
	(3)针对所有的元素重复以上的步骤，除了最后一个。
	(4)持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。
	
时间复杂度和算法稳定性：

	一共遍历了n-1 + n-2 + … + 2 + 1 = n * (n-1) / 2 = 0.5 * n ^ 2 - 0.5 * n，那么时间复杂度是O(N^2)。
	因为nums[j]==nums[j+1]的时候，我们可以不移动nums[i]和nums[j]，所以冒泡排序是稳定的。

冒泡排序优化：

	初始didswap=false. 当发生一次交换就将didswap置为true，这样如果原始有序，那么一次扫描完一次交换也不会有，
	即didswap=false，此时return，终止排序。此时时间复杂度是O（n）
	
2.2 选择排序

算法原理:(升序)

	(1)在待排序的一组数中选出最小(或最大)的一个元素，与待排序序列的起始位置(或末尾位置）交换。
	(2)然后在剩下的数中再找最小（或者最大）的与第2个位置的数交换。
	(3)以此类推，知道第n-1个元素（倒数第二个数）和第n个元素（最后一个数）比较为止。
	
时间复杂度和算法稳定性：

	时间复杂度：
	简单选择排序的比较次数与序列的初始排序无关。假设待排序的系列有N个元素，则比较次数总是N（N-1）/2
	而移动次数与系列的初始排序有关，当排序正序时，移动次数最少，为0
	当序列反序时，移动次数最多，为3N（N-1）/2；所以，综上，简单排序的时间复杂度为O（N*N）

	选择排序是不稳定的：选择排序是给每个位置选择当前元素最小的，比如给第一个位置选择最小的，在剩余元素里面给第二个元素选择第二小的，
	依次类推，直到第n - 1个元素，第n个元素不用选择了，因为只剩下它一个最大的元素了。
	那么，在一趟选择，如果当前元素比一个元素小，而该小的元素又出现在一个和当前元素相等 的元素后面，
	那么交换后稳定性就被破坏了。比较拗口，举个例子，序列5 8 5 2 9，我们知道第一遍选择第1个元素5会和2交换，
	那么原序列中2个5的相对前后顺序就被破坏了，所以选择排序不是一个稳定的排序算法。

选择排序优化：

		选择排序是一次确定一个元素的位置，而选择排序的优化则是一次确定两个元素的位置，比如降序：每次将最小值放在起始位置，最大值放在末尾位置。

	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	