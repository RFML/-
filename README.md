
参考博客：https://blog.csdn.net/u013457167/article/details/81989207

一、算法概述

1.1 算法分类

比较类排序：通过比较来决定元素间的相对次序。
时间复杂度O(nlogn) ~ O(n^2)，主要有：冒泡排序，选择排序，插入排序，归并排序，堆排序，快速排序等。
 
非比较排序，不通过比较来决定元素间的相对次序 
时间复杂度可以达到O(n)，主要有：计数排序，基数排序，桶排序等。 

分类图如下：
![Image text](https://github.com/RFML/sortofeight/blob/master/images/排序算法分类.png)

1.2 算法复杂度及稳定性
![Image text](https://github.com/RFML/sortofeight/blob/master/images/各类排序算法复杂度.png)

二、详细讲解
2.1 冒泡排序
算法原理:(升序)
	(1)比较相邻的元素。如果第一个比第二个大，就交换他们两个。
	(2)对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。在这一步，最后的元素应该会是最大的数。
	(3)针对所有的元素重复以上的步骤，除了最后一个。
	(4)持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。
	
时间复杂度和算法稳定性：
	一共遍历了n-1 + n-2 + … + 2 + 1 = n * (n-1) / 2 = 0.5 * n ^ 2 - 0.5 * n，那么时间复杂度是O(N^2)。
	因为nums[j]==nums[j+1]的时候，我们可以不移动nums[i]和nums[j]，所以冒泡排序是稳定的。

冒泡排序优化：
	初始didswap=false. 当发生一次交换就将didswap置为true，这样如果原始有序，那么一次扫描完一次交换也不会有，
	即didswap=false，此时return，终止排序。此时时间复杂度是O（n）